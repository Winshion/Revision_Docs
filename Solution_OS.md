### 题目：参考《操作系统》试卷

如果下述有看不懂的，建议认真复习“虚拟内存管理”章节！

题目考的是数组分配内容，首先明确数组分配的原则：

数组在内存中<strong>按行线性存储</strong>。如果是一个多维数组，那么按照序号从小到大仍然是按行存储。

例：arr[3][3]在内存中的存储就是：

a[0][0]  a[0][1]  a[0][2]  a[1][0] ... a[2][2].

在该题中，同样地，数组都是按行存储。

##### 第一问

题目要求计算A和B运行到i=28，j=7时共发生多少次缺页异常，那就必须知道一个页可以存放下多少数组元素。这是因为这两段代码都是给数组元素赋值，相当于都要访问内存。若访问的数组元素不在物理内存（如果不知道什么叫物理地址和逻辑地址，建议仔细看书）中，则需要陷入page fault把在磁盘中的页面调进来。

题中所给的页面大小为：256B

数组共256行，64列。按照前面讲过的数组按行存取，那么一行所需要的存储空间为

$4\times 64=256$

4代表一个INT占用4B的内存，一行有64个元素，所以数组一行共需要256Bytes的存储空间。

> 数组的一行正好能够放进一个页面中！

<strong>那就意味着，每次换行的时候，都需要发生一次page fault。</strong>

首先计算A方式：A方式是按列（竖着）读取，意味着读取顺序是这样的：

↓    ↓    ↓    ↓  ...↓    ↓

每访问一个元素都需要换行！所以访问了多少个元素就要发生多少次page fault。

因此A方法发生的缺页异常数为

$256\times 7+29=1821$

（注意：数组索引是从0开始的）

对于B方法，则是按行（横着）访问。

所以每换一次行，发生一次page fault，一共发生29次page fault。

##### 第二问

仔细阅读题目：系统给该进程分配了7个页面，由于已经有一个常驻页面，因此<strong>可以使用的只有6个页面</strong>，按照题目要求，分别编号1，2，3，4，5，6.

使用LRU方法，由于题目所给条件下每一次都需要更换新的页面，所以该算法退化成FIFO。

对于A方法：

> A方法每一次换页都需要进行一次page fault。若使用p(l)表示第p个页面中存储数组的第i行，那么整个换页过程就会是：
> 
> 1(0); 2(1); 3(2); 4(3); ... ; 6(5); 1(6); 2(7), ...        // 自己定义的标注法，考试不能这么写！
> 
> 即：第一次发生页面错误时第1页存储数组的第0行；第二次发生页面错误时第2页存储数组的第1行，依次类推。如果6个页都存满了，那就把第1页里面的换下来，把需要的数组行数换上去。
> 
> 计算行号，可以采用取模的方法。首先计算a[28][7]在第几页，然后倒推回去。
> 
> 共发生1821次page fault，1821 % 6 = 3，所以页号为3的那一帧存放数组的第28行
> 
> 答案：页号    1        2        3        4        5        6
> 
>     数组行号   26      27      <strong>28</strong>      23     24      25

对于B方法：

> B方法很简单，用29 % 6得到的答案就是最终的结果
> 
> 答案：页号    1        2        3        4        5        6
> 
>     数组行号   24      25      26     27      <strong>28</strong>      23

##### 第三问

第三问结果按照第二问的行号对应题目中物理地址的表抄上去就好
